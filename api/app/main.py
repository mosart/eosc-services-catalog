"""FastAPI application exposing the EOSC service catalogue demonstrator."""

from __future__ import annotations

from typing import Any, Dict, Iterable, List, Optional

from fastapi import FastAPI, HTTPException, Query
from fastapi.openapi.utils import get_openapi
from fastapi.responses import RedirectResponse

from .data import get_service_schema, load_service_bundles

# Configure the FastAPI application with versioned URLs for metadata endpoints so
# that the served OpenAPI document can be embedded directly in future clients.
app = FastAPI(
    title="EOSC Service Catalogue Demonstrator",
    version="0.2.0",
    description=(
        "Minimal reference implementation of the EOSC service catalogue API "
        "as described in Appendix A of the federation guidelines."
    ),
    openapi_url="/api/v1/openapi.json",
    docs_url="/api/v1/docs",
    redoc_url="/api/v1/redoc",
)

# Allow clients to sort by a small set of safe string attributes. Keeping this in
# one place makes it easier to expand later while also validating user input.
_ALLOWED_SORT_FIELDS = {"name", "abbreviation", "lifeCycleStatus"}


def _normalise(text: Optional[str]) -> str:
    """Return a case-folded version of ``text`` for insensitive comparisons."""
    return (text or "").casefold()


def _iter_services() -> Iterable[Dict[str, Any]]:
    """Yield the loaded service bundles so they can be reused across handlers."""
    yield from load_service_bundles()


@app.get("/", include_in_schema=False)
def redirect_to_docs() -> RedirectResponse:
    """Send browsers landing on the root URL straight to the Swagger UI."""
    return RedirectResponse(url="/api/v1/docs", status_code=307)


@app.get("/healthz", tags=["health"])
def health_check() -> Dict[str, str]:
    """Return a simple health indicator."""
    return {"status": "ok"}


@app.get("/api/v1/services/{prefix}/{suffix}", tags=["services"])
def get_service(prefix: str, suffix: str) -> Dict[str, Any]:
    """Return a single service bundle identified by ``prefix`` and ``suffix``."""
    service_id = f"{prefix}/{suffix}"
    for bundle in _iter_services():
        service = bundle.get("service", {})
        if service.get("id") == service_id:
            return bundle
    raise HTTPException(status_code=404, detail="Service not found")


@app.get("/api/v1/services", tags=["services"])
def list_services(
    active: Optional[bool] = Query(None, description="Filter by active flag"),
    keyword: Optional[str] = Query(
        None,
        description="Keyword matched against name, description, tagline, and tags",
    ),
    skip: int = Query(0, alias="from", ge=0, description="Start offset in the result set"),
    quantity: int = Query(
        10,
        alias="quantity",
        ge=1,
        le=100,
        description="Number of results to return",
    ),
    order: str = Query(
        "asc",
        description="Sort order (asc or desc)",
    ),
    sort: str = Query(
        "name",
        description="Field used for ordering",
    ),
) -> Dict[str, Any]:
    """Return service bundles that match the provided filters."""
    sort_field = sort
    if sort_field not in _ALLOWED_SORT_FIELDS:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported sort field '{sort_field}'. Allowed: {sorted(_ALLOWED_SORT_FIELDS)}",
        )

    order_value = order.lower()
    if order_value not in {"asc", "desc"}:
        raise HTTPException(
            status_code=400,
            detail="Unsupported order value. Allowed: ['asc', 'desc']",
        )

    filtered: List[Dict[str, Any]] = []
    for bundle in _iter_services():
        if active is not None and bundle.get("active") is not active:
            continue

        if keyword:
            svc = bundle.get("service", {})
            haystack = " ".join(
                [
                    svc.get("name", ""),
                    svc.get("description", ""),
                    svc.get("tagline", ""),
                    " ".join(svc.get("tags", [])),
                ]
            )
            if keyword.casefold() not in _normalise(haystack):
                continue

        filtered.append(bundle)

    reverse = order_value == "desc"

    def sort_key(item: Dict[str, Any]) -> Any:
        service = item.get("service", {})
        return _normalise(service.get(sort_field))

    filtered.sort(key=sort_key, reverse=reverse)

    total = len(filtered)
    paginated = filtered[skip : skip + quantity]

    return {
        "items": paginated,
        "total": total,
        "from": skip,
        "quantity": len(paginated),
        "order": order_value,
        "sort": sort_field,
    }


@app.get("/api/v1/schema", tags=["metadata"])
def get_schema() -> Dict[str, Any]:
    """Expose the EOSC service bundle JSON schema used for validation."""
    return get_service_schema()


def _custom_openapi() -> Dict[str, Any]:
    """Augment FastAPI's autogenerated document with our bundle schema."""
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
    )

    components = openapi_schema.setdefault("components", {}).setdefault("schemas", {})
    components.setdefault("ServiceBundle", get_service_schema())
    components.setdefault(
        "ServiceBundleList",
        {
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {"$ref": "#/components/schemas/ServiceBundle"},
                },
                "total": {"type": "integer"},
                "from": {"type": "integer"},
                "quantity": {"type": "integer"},
                "order": {"type": "string"},
                "sort": {"type": "string"},
            },
        },
    )

    # Rewire endpoint metadata so Swagger can display the enriched schemas.
    paths = openapi_schema.get("paths", {})
    if "/api/v1/services" in paths:
        paths["/api/v1/services"].setdefault("get", {}).setdefault("responses", {}).setdefault(
            "200",
            {
                "description": "Service bundles matching the provided filters",
                "content": {
                    "application/json": {
                        "schema": {"$ref": "#/components/schemas/ServiceBundleList"}
                    }
                },
            },
        )
    if "/api/v1/services/{prefix}/{suffix}" in paths:
        paths["/api/v1/services/{prefix}/{suffix}"].setdefault("get", {}).setdefault(
            "responses", {}
        ).setdefault(
            "200",
            {
                "description": "Single service bundle",
                "content": {
                    "application/json": {
                        "schema": {"$ref": "#/components/schemas/ServiceBundle"}
                    }
                },
            },
        )

    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = _custom_openapi
